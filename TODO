Introduction to MPI, basic concepts

einarbeiten in valgrind -> an openmpi anpassen (openmpi neu kompilieren)

Use VecCreateGhost(MPI Comm comm,int n,int N,int nghost,int *ghosts,Vec *vv) instead of scatter routines

Peric -> PetscMapping über AO realisieren

nochmal .git manual durcharbeiten
http://rwehner.wordpress.com/2010/03/01/a-simple-way-to-create-git-repository-on-a-server-machine-connecting-via-ssh/

WICHTIG:

Error Output in Textfile wieder implementieren
Nochmals komplette Order Verification durchspielen (mit Zeitabhängigkeit)
Comment Variables in index module
Mit Michel petsc configuration am FNB besprechen
Solver mit nicht quadratischer domain testen (order verification)

automatisierung der gittergenerierung preprocessing und solve mittels bash-skript
Variablengrößen an "maximal load" bei Kompilierung anpassen (Aufgabe von preprocessing.f90) -> preprocessing muss bereits über die prozessorbelastung informiert sein: Einlesen von proc_*.inp, sodass die locale Auslastung berechnet werden kann.

Entweder DT in controlModule setzen oder aus processorFile lesen (dort dann aber auch Blending und URF setzen

MMS mit Trigonometrischen Funktionen für Skalarfeld und Geschwindigkeit

OPTIONAL: 

Use Petsc LOG-FILES
Iterationen in GradFi einbauen
Use PETSC-Routine to determine Convergence: KSPDefaultConverged
preprocessing und grgen parallelisieren (müsste über geeignete input files machbar sein)
Mat get info verwenden

Delete PETSc Objects to avoid memory leak -> no memory leak

Remapping im preprocessing abschaffen!!! Am besten ist wohl ein prozessor locales remapping -> IJKPROC muss nur noch bei MIJK verwendet werden; L(F) sollte locale indices beinhalten, R(F) globale (Peric Indizierung) -> kann aber als inkohärent aufgefasst werden -> vorerst nicht implementiert

---------------------------------------------------------------------------

Aufbau eines procfiles

NUMBER OF BLOCKS
LOCAL BLOCK INDEXING
DT (0 -> STATIONARY)
BLENDING FACTOR (G)
UNDERRELAXATION FACTOR (URF)
INFO LOCICAL






